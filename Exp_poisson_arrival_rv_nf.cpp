//
// Created by bacox on 25/05/2020.
//

#include <iostream>
#include <EdgeCaffe.h>
#include <chrono>
#include <Util/Output.h>
#include <cxxopts.h>
#include <Util/Config.h>
#include <TaskPool/AbstractTaskPool.h>
#include <TaskPool/AbstractPriorityTaskPool.h>

int main(int argc, char *argv[])
{
    /**
     * Vary Rho, fix number of networks
     */

    /**
     * Start parsing input parameters
     */

    EdgeCaffe::Config &c_config = EdgeCaffe::Config::getInstance();

    c_config.parseCli(argc, argv);
    c_config.printConfig();

    std::unordered_map<std::string, int> memory_values = {
            {"512M", 512}
            , {"1G", 1024}
            , {"2G", 2048}
            , {"4G", 4096}

    };
    /**
     * End parsing input parameters
     */

    EdgeCaffe::Orchestrator::MODEL_SPLIT_MODE mode = EdgeCaffe::Orchestrator::MODEL_SPLIT_MODE::PARTIAL;
    std::string modeAsString = "partial";
    std::string defaultMode = c_config.mode.valueOrDefault();
    if (defaultMode == "bulk")
    {
        mode = EdgeCaffe::Orchestrator::MODEL_SPLIT_MODE::BULK;
        modeAsString = "bulk";
    } else if (defaultMode == "deepeye")
    {
        mode = EdgeCaffe::Orchestrator::MODEL_SPLIT_MODE::DEEPEYE;
        modeAsString = "deepeye";
    } else if (defaultMode == "linear")
    {
        mode = EdgeCaffe::Orchestrator::MODEL_SPLIT_MODE::LINEAR;
        modeAsString = "linear";
    } else if (defaultMode == "execprio")
    {
        mode = EdgeCaffe::Orchestrator::MODEL_SPLIT_MODE::PRIO_EXEC;
        modeAsString = "execprio";
    }else if (defaultMode == "execprio-inter")
    {
        mode = EdgeCaffe::Orchestrator::MODEL_SPLIT_MODE::PRIO_EXEC_INTER;
        modeAsString = "execprio-inter";
    } else if (defaultMode == "masa-p")
    {
        mode = EdgeCaffe::Orchestrator::MODEL_SPLIT_MODE::MASA_P;
        modeAsString = "masa-p";
    } else if (defaultMode == "masa-e")
    {
        mode = EdgeCaffe::Orchestrator::MODEL_SPLIT_MODE::MASA_E;
        modeAsString = "masa-e";
    }
    std::string outputFile = "output.csv";

    {
        EdgeCaffe::Output output;
        std::string configOutputFile = c_config.outputPrefix.valueOrDefault() + "config.csv";
        output.toCSV(c_config.outputDirectory.valueOrDefault() + "/" + configOutputFile, c_config.configAsText, EdgeCaffe::Output::CONFIG);
    }


    EdgeCaffe::AbstractPriorityTaskPool atp;

    EdgeCaffe::Task *t1 = new EdgeCaffe::LoadTask(0, 1, "First task");
    t1->t_type = EdgeCaffe::Task::LOAD;
    EdgeCaffe::Task *t2 = new EdgeCaffe::LoadTask(1, 1, "Second task");
    t2->t_type = EdgeCaffe::Task::LOAD;
    EdgeCaffe::Task *t3 = new EdgeCaffe::ExecTask(2, 1, "First Exec Task");
    t3->t_type = EdgeCaffe::Task::EXEC;

    atp.addTask(t1);
    atp.addTask(t2);
    atp.addTask(t3);


    /**
     * End of configuring all.
     * The real running begins here
     */
//    if(!verbose)
    ::google::InitGoogleLogging(argv[0]);

    EdgeCaffe::Orchestrator orchestrator;

    /**
     * Instead of defining the networks and the input, we let it be generated by a distribution
     */
    EdgeCaffe::ArrivalList arrivals;

    /**
     * Check if an arrival-list is given
     * If an arrival-list is present we will you that one instead of generating arrivals
     * If no arrival-list --> generate arrivals according to the distribution
     */

    if( c_config.pathToArrivalList.isSet())
    {
//        std::cout << "I found an arrival-list at " << pathToArrivalList << std::endl;
        arrivals.loadFromYaml(c_config.pathToArrivalList());
    } else
    {
//        std::cout << "No arrivalList to be found" << std::endl;
        arrivals.setEnabledNetworks({c_config.networks()});
        arrivals.setSeed(c_config.seed());

        if (c_config.poissonDistribution())
        {
            arrivals.generateList(c_config.numArrivals(), EdgeCaffe::ArrivalList::DISTRIBUTION_TYPE::POISSON, {c_config.iat()});
        } else
        {
            arrivals.generateList(c_config.numArrivals(), EdgeCaffe::ArrivalList::DISTRIBUTION_TYPE::CONSTANT, {0});
        }
    }
    {
        // Make sure to save the arrival distribution
        std::string arrivalListOutputFile = c_config.defaultOutPath() + "arrivals.csv";
        EdgeCaffe::Output output;
        output.toCSV(arrivalListOutputFile, arrivals.toCSVLines(), EdgeCaffe::Output::ARRIVALS);
    }


    orchestrator.setup(mode, modeAsString, c_config.numberOfWorkers());
    orchestrator.verbose = c_config.verbose();
    for(const auto &worker : orchestrator.getWorkers())
        worker->verbose = c_config.verbose();
    orchestrator.setArrivals(arrivals);

    auto startTime = std::chrono::high_resolution_clock::now();
    orchestrator.mc.setCapacity(memory_values[c_config.memoryLimit()]); // In MB
    orchestrator.mc.lockMemory(4.87); // Base usage of the pipeline
    orchestrator.start();
    orchestrator.processTasks();
    orchestrator.waitForStop();

    auto endTime = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime).count();
    std::cout << duration << " milliseconds" << std::endl;





    /**
     * Processing the gathered data
     * This part writes the timing information of the layers of the networks to a csv file.
     * It overwrites the specified file. It is important to use a unique filename
     *  for each run of move the data in between runs to prevent losing data.
     */

    std::string layerOutputFile = c_config.defaultOutPath() + outputFile;
    orchestrator.processLayerData(layerOutputFile);
    std::string queueEventsFile = c_config.defaultOutPath() + "stepEvents.csv";
    orchestrator.processEventData(queueEventsFile, startTime);
    std::string networkOutputFile = c_config.defaultOutPath() + "networkStats6.csv";
    orchestrator.processNetworkData(networkOutputFile, startTime);

    /**
     * Save the output of the end-to-end measurement
     * Here we append the measurement to the file
     * If the file does not exist it is created.
     */
    EdgeCaffe::Output output;
    std::string generalLine = c_config.memoryLimit() + "," + modeAsString + "," + std::to_string(duration) + "," + std::to_string(c_config.numArrivals()) + "," + c_config.networks().front() + "," + std::to_string(1) + "," + std::to_string(0) + "," + std::to_string(c_config.iat()) + "," + std::to_string(c_config.numberOfWorkers());
    output.toCSVAppend(c_config.outputDirectory() + "/" + c_config.generalOutputFile(), {generalLine}, EdgeCaffe::Output::PIPELINE_EXT);


    for(auto worker : orchestrator.getWorkers())
    {
        auto id = worker->workerId;
        std::string workerStatFile = c_config.defaultOutPath() + "worker" + std::to_string(id) + ".csv";
        auto lines = worker->workerProfileToCSVLines();
        output.toCSV(workerStatFile, lines, EdgeCaffe::Output::WORKER);
    }

    output.toCSV(c_config.defaultOutPath() + "cc-networks.csv", orchestrator.nr.toCSV(), EdgeCaffe::Output::CONCURRENT_NETWORKS);
    return 0;
}